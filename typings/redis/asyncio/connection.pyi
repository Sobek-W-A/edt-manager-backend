"""
This type stub file was generated by pyright.
"""

import asyncio
import enum
import ssl
import sys
import hiredis
from abc import abstractmethod
from typing import Any, Callable, Iterable, List, Mapping, Optional, Tuple, Type, TypeVar, Union
from redis.asyncio.retry import Retry
from redis.compat import Protocol, TypedDict
from redis.credentials import CredentialProvider
from redis.exceptions import ResponseError
from redis.typing import EncodableT, EncodedT
from redis.utils import HIREDIS_AVAILABLE

if sys.version_info >= (3, 11, 3):
    ...
else:
    ...
hiredis = ...
if HIREDIS_AVAILABLE:
    ...
SYM_STAR = ...
SYM_DOLLAR = ...
SYM_CRLF = ...
SYM_LF = ...
SYM_EMPTY = ...
SERVER_CLOSED_CONNECTION_ERROR = ...
class _Sentinel(enum.Enum):
    sentinel = ...


SENTINEL = ...
MODULE_LOAD_ERROR = ...
NO_SUCH_MODULE_ERROR = ...
MODULE_UNLOAD_NOT_POSSIBLE_ERROR = ...
MODULE_EXPORTS_DATA_TYPES_ERROR = ...
NO_AUTH_SET_ERROR = ...
class _HiredisReaderArgs(TypedDict, total=False):
    protocolError: Callable[[str], Exception]
    replyError: Callable[[str], Exception]
    encoding: Optional[str]
    errors: Optional[str]
    ...


class Encoder:
    """Encode strings to bytes-like and decode bytes-like to strings"""
    __slots__ = ...
    def __init__(self, encoding: str, encoding_errors: str, decode_responses: bool) -> None:
        ...
    
    def encode(self, value: EncodableT) -> EncodedT:
        """Return a bytestring or bytes-like representation of the value"""
        ...
    
    def decode(self, value: EncodableT, force=...) -> EncodableT:
        """Return a unicode string from the bytes-like representation"""
        ...
    


ExceptionMappingT = Mapping[str, Union[Type[Exception], Mapping[str, Type[Exception]]]]
class BaseParser:
    """Plain Python parsing class"""
    __slots__ = ...
    EXCEPTION_CLASSES: ExceptionMappingT = ...
    def __init__(self, socket_read_size: int) -> None:
        ...
    
    @classmethod
    def parse_error(cls, response: str) -> ResponseError:
        """Parse an error response"""
        ...
    
    def on_disconnect(self):
        ...
    
    def on_connect(self, connection: AbstractConnection):
        ...
    
    async def can_read_destructive(self) -> bool:
        ...
    
    async def read_response(self, disable_decoding: bool = ...) -> Union[EncodableT, ResponseError, None, List[EncodableT]]:
        ...
    


class PythonParser(BaseParser):
    """Plain Python parsing class"""
    __slots__ = ...
    def __init__(self, socket_read_size: int) -> None:
        ...
    
    def on_connect(self, connection: AbstractConnection): # -> None:
        """Called when the stream connects"""
        ...
    
    def on_disconnect(self): # -> None:
        """Called when the stream disconnects"""
        ...
    
    async def can_read_destructive(self) -> bool:
        ...
    
    async def read_response(self, disable_decoding: bool = ...): # -> EncodableT | ResponseError | None:
        ...
    


class HiredisParser(BaseParser):
    """Parser class for connections using Hiredis"""
    __slots__ = ...
    def __init__(self, socket_read_size: int) -> None:
        ...
    
    def on_connect(self, connection: AbstractConnection): # -> None:
        ...
    
    def on_disconnect(self): # -> None:
        ...
    
    async def can_read_destructive(self): # -> bool:
        ...
    
    async def read_from_socket(self): # -> Literal[True]:
        ...
    
    async def read_response(self, disable_decoding: bool = ...) -> Union[EncodableT, List[EncodableT]]:
        ...
    


DefaultParser: Type[Union[PythonParser, HiredisParser]]
if HIREDIS_AVAILABLE:
    DefaultParser = ...
else:
    DefaultParser = ...
class ConnectCallbackProtocol(Protocol):
    def __call__(self, connection: AbstractConnection): # -> None:
        ...
    


class AsyncConnectCallbackProtocol(Protocol):
    async def __call__(self, connection: AbstractConnection): # -> None:
        ...
    


ConnectCallbackT = Union[ConnectCallbackProtocol, AsyncConnectCallbackProtocol]
class AbstractConnection:
    """Manages communication to and from a Redis server"""
    __slots__ = ...
    def __init__(self, *, db: Union[str, int] = ..., password: Optional[str] = ..., socket_timeout: Optional[float] = ..., socket_connect_timeout: Optional[float] = ..., retry_on_timeout: bool = ..., retry_on_error: Union[list, _Sentinel] = ..., encoding: str = ..., encoding_errors: str = ..., decode_responses: bool = ..., parser_class: Type[BaseParser] = ..., socket_read_size: int = ..., health_check_interval: float = ..., client_name: Optional[str] = ..., username: Optional[str] = ..., retry: Optional[Retry] = ..., redis_connect_func: Optional[ConnectCallbackT] = ..., encoder_class: Type[Encoder] = ..., credential_provider: Optional[CredentialProvider] = ...) -> None:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    @abstractmethod
    def repr_pieces(self): # -> None:
        ...
    
    @property
    def is_connected(self): # -> bool:
        ...
    
    def register_connect_callback(self, callback): # -> None:
        ...
    
    def clear_connect_callbacks(self): # -> None:
        ...
    
    def set_parser(self, parser_class: Type[BaseParser]) -> None:
        """
        Creates a new instance of parser_class with socket size:
        _socket_read_size and assigns it to the parser for the connection
        :param parser_class: The required parser class
        """
        ...
    
    async def connect(self): # -> None:
        """Connects to the Redis server if not already connected"""
        ...
    
    async def on_connect(self) -> None:
        """Initialize the connection, authenticate and select a database"""
        ...
    
    async def disconnect(self, nowait: bool = ...) -> None:
        """Disconnects from the Redis server"""
        ...
    
    async def check_health(self): # -> None:
        """Check the health of the connection with a PING/PONG"""
        ...
    
    async def send_packed_command(self, command: Union[bytes, str, Iterable[bytes]], check_health: bool = ...) -> None:
        ...
    
    async def send_command(self, *args: Any, **kwargs: Any) -> None:
        """Pack and send a command to the Redis server"""
        ...
    
    async def can_read_destructive(self): # -> bool:
        """Poll the socket to see if there's data that can be read."""
        ...
    
    async def read_response(self, disable_decoding: bool = ..., timeout: Optional[float] = ..., *, disconnect_on_error: bool = ...): # -> EncodableT | bytearray | memoryview[_I] | List[EncodableT] | None:
        """Read the response from a previously sent command"""
        ...
    
    def pack_command(self, *args: EncodableT) -> List[bytes]:
        """Pack a series of arguments into the Redis protocol"""
        ...
    
    def pack_commands(self, commands: Iterable[Iterable[EncodableT]]) -> List[bytes]:
        """Pack multiple commands into the Redis protocol"""
        ...
    


class Connection(AbstractConnection):
    "Manages TCP communication to and from a Redis server"
    def __init__(self, *, host: str = ..., port: Union[str, int] = ..., socket_keepalive: bool = ..., socket_keepalive_options: Optional[Mapping[int, Union[int, bytes]]] = ..., socket_type: int = ..., **kwargs) -> None:
        ...
    
    def repr_pieces(self): # -> list[Any]:
        ...
    


class SSLConnection(Connection):
    """Manages SSL connections to and from the Redis server(s).
    This class extends the Connection class, adding SSL functionality, and making
    use of ssl.SSLContext (https://docs.python.org/3/library/ssl.html#ssl.SSLContext)
    """
    def __init__(self, ssl_keyfile: Optional[str] = ..., ssl_certfile: Optional[str] = ..., ssl_cert_reqs: str = ..., ssl_ca_certs: Optional[str] = ..., ssl_ca_data: Optional[str] = ..., ssl_check_hostname: bool = ..., **kwargs) -> None:
        ...
    
    @property
    def keyfile(self): # -> str | None:
        ...
    
    @property
    def certfile(self): # -> str | None:
        ...
    
    @property
    def cert_reqs(self): # -> VerifyMode:
        ...
    
    @property
    def ca_certs(self): # -> str | None:
        ...
    
    @property
    def ca_data(self): # -> str | None:
        ...
    
    @property
    def check_hostname(self): # -> bool:
        ...
    


class RedisSSLContext:
    __slots__ = ...
    def __init__(self, keyfile: Optional[str] = ..., certfile: Optional[str] = ..., cert_reqs: Optional[str] = ..., ca_certs: Optional[str] = ..., ca_data: Optional[str] = ..., check_hostname: bool = ...) -> None:
        ...
    
    def get(self) -> ssl.SSLContext:
        ...
    


class UnixDomainSocketConnection(AbstractConnection):
    "Manages UDS communication to and from a Redis server"
    def __init__(self, *, path: str = ..., **kwargs) -> None:
        ...
    
    def repr_pieces(self) -> Iterable[Tuple[str, Union[str, int]]]:
        ...
    


FALSE_STRINGS = ...
def to_bool(value) -> Optional[bool]:
    ...

URL_QUERY_ARGUMENT_PARSERS: Mapping[str, Callable[..., object]] = ...
class ConnectKwargs(TypedDict, total=False):
    username: str
    password: str
    connection_class: Type[AbstractConnection]
    host: str
    port: int
    db: int
    path: str
    ...


def parse_url(url: str) -> ConnectKwargs:
    ...

_CP = TypeVar("_CP", bound="ConnectionPool")
class ConnectionPool:
    """
    Create a connection pool. ``If max_connections`` is set, then this
    object raises :py:class:`~redis.ConnectionError` when the pool's
    limit is reached.

    By default, TCP connections are created unless ``connection_class``
    is specified. Use :py:class:`~redis.UnixDomainSocketConnection` for
    unix sockets.

    Any additional keyword arguments are passed to the constructor of
    ``connection_class``.
    """
    @classmethod
    def from_url(cls: Type[_CP], url: str, **kwargs) -> _CP:
        """
        Return a connection pool configured from the given URL.

        For example::

            redis://[[username]:[password]]@localhost:6379/0
            rediss://[[username]:[password]]@localhost:6379/0
            unix://[username@]/path/to/socket.sock?db=0[&password=password]

        Three URL schemes are supported:

        - `redis://` creates a TCP socket connection. See more at:
          <https://www.iana.org/assignments/uri-schemes/prov/redis>
        - `rediss://` creates a SSL wrapped TCP socket connection. See more at:
          <https://www.iana.org/assignments/uri-schemes/prov/rediss>
        - ``unix://``: creates a Unix Domain Socket connection.

        The username, password, hostname, path and all querystring values
        are passed through urllib.parse.unquote in order to replace any
        percent-encoded values with their corresponding characters.

        There are several ways to specify a database number. The first value
        found will be used:
            1. A ``db`` querystring option, e.g. redis://localhost?db=0
            2. If using the redis:// or rediss:// schemes, the path argument
               of the url, e.g. redis://localhost/0
            3. A ``db`` keyword argument to this function.

        If none of these options are specified, the default db=0 is used.

        All querystring options are cast to their appropriate Python types.
        Boolean arguments can be specified with string values "True"/"False"
        or "Yes"/"No". Values that cannot be properly cast cause a
        ``ValueError`` to be raised. Once parsed, the querystring arguments
        and keyword arguments are passed to the ``ConnectionPool``'s
        class initializer. In the case of conflicting arguments, querystring
        arguments always win.
        """
        ...
    
    def __init__(self, connection_class: Type[AbstractConnection] = ..., max_connections: Optional[int] = ..., **connection_kwargs) -> None:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def reset(self): # -> None:
        ...
    
    async def get_connection(self, command_name, *keys, **options): # -> AbstractConnection:
        """Get a connection from the pool"""
        ...
    
    def get_encoder(self):
        """Return an encoder based on encoding settings"""
        ...
    
    def make_connection(self): # -> AbstractConnection:
        """Create a new connection"""
        ...
    
    async def release(self, connection: AbstractConnection): # -> None:
        """Releases the connection back to the pool"""
        ...
    
    def owns_connection(self, connection: AbstractConnection): # -> bool:
        ...
    
    async def disconnect(self, inuse_connections: bool = ...): # -> None:
        """
        Disconnects connections in the pool

        If ``inuse_connections`` is True, disconnect connections that are
        current in use, potentially by other tasks. Otherwise only disconnect
        connections that are idle in the pool.
        """
        ...
    
    def set_retry(self, retry: Retry) -> None:
        ...
    


class BlockingConnectionPool(ConnectionPool):
    """
    Thread-safe blocking connection pool::

        >>> from redis.client import Redis
        >>> client = Redis(connection_pool=BlockingConnectionPool())

    It performs the same function as the default
    :py:class:`~redis.ConnectionPool` implementation, in that,
    it maintains a pool of reusable connections that can be shared by
    multiple redis clients (safely across threads if required).

    The difference is that, in the event that a client tries to get a
    connection from the pool when all of connections are in use, rather than
    raising a :py:class:`~redis.ConnectionError` (as the default
    :py:class:`~redis.ConnectionPool` implementation does), it
    makes the client wait ("blocks") for a specified number of seconds until
    a connection becomes available.

    Use ``max_connections`` to increase / decrease the pool size::

        >>> pool = BlockingConnectionPool(max_connections=10)

    Use ``timeout`` to tell it either how many seconds to wait for a connection
    to become available, or to block forever:

        >>> # Block forever.
        >>> pool = BlockingConnectionPool(timeout=None)

        >>> # Raise a ``ConnectionError`` after five seconds if a connection is
        >>> # not available.
        >>> pool = BlockingConnectionPool(timeout=5)
    """
    def __init__(self, max_connections: int = ..., timeout: Optional[int] = ..., connection_class: Type[AbstractConnection] = ..., queue_class: Type[asyncio.Queue] = ..., **connection_kwargs) -> None:
        ...
    
    def reset(self): # -> None:
        ...
    
    def make_connection(self): # -> AbstractConnection:
        """Make a fresh connection."""
        ...
    
    async def get_connection(self, command_name, *keys, **options): # -> AbstractConnection:
        """
        Get a connection, blocking for ``self.timeout`` until a connection
        is available from the pool.

        If the connection returned is ``None`` then creates a new connection.
        Because we use a last-in first-out queue, the existing connections
        (having been returned to the pool after the initial ``None`` values
        were added) will be returned before ``None`` values. This means we only
        create new connections when we need to, i.e.: the actual number of
        connections will only increase in response to demand.
        """
        ...
    
    async def release(self, connection: AbstractConnection): # -> None:
        """Releases the connection back to the pool."""
        ...
    
    async def disconnect(self, inuse_connections: bool = ...): # -> None:
        """Disconnects all connections in the pool."""
        ...
    


